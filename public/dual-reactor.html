<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Trading Reactors</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  background: transparent;
  overflow: hidden;
}

canvas {
  display: block;
}
</style>
</head>

<body>
<canvas id="c" width="520" height="260"></canvas>

<script>
/* ======================================================
   CONFIG
====================================================== */

const ENGINE_URL =
  "https://trading-dashboard-api-five.vercel.app/api/engine-ui?t=";

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

const REACTOR_RADIUS = 58;
const INNER_RADIUS = 44;
const WEEKLY_X = 170;
const MONTHLY_X = 350;
const CENTER_Y = 130;

/* ======================================================
   STATE
====================================================== */

let data = null;
let glowPhase = 0;
let corePhase = 0;
let wavePhaseA = 0;
let wavePhaseB = 0;

/* burst bubbles */
const burstBubbles = [];
let lastBurst = 0;

/* ======================================================
   FETCH
====================================================== */

async function fetchData() {
  try {
    const res = await fetch(ENGINE_URL + Date.now(), { cache: "no-store" });
    data = await res.json();
  } catch {}
}

fetchData();
setInterval(fetchData, 10000);

/* ======================================================
   HELPERS
====================================================== */

function clamp(v) {
  return Math.max(0, Math.min(1, v));
}

function spawnBurst(cx, surfaceY, color) {
  burstBubbles.push({
    x: cx,
    y: surfaceY,
    r: 2.6 + Math.random() * 0.6,
    life: 1,
    speed: 0.6 + Math.random() * 0.2,
    color
  });
}

/* ======================================================
   COLOR RULES
====================================================== */

function getBaseColor(type) {
  return type === "weekly"
    ? "rgba(110,255,215,1)"
    : "rgba(120,235,170,1)";
}

function getState(d) {
  if (!d.hasTrades) return "IDLE";
  if (d.pl < 0) return "WARNING";
  if (d.pl === 0) return "BREAKEVEN";
  return "HEALTHY";
}

/* ======================================================
   DRAW FUNCTIONS
====================================================== */

function drawInnerCore(cx) {
  corePhase += 0.05;

  const g = ctx.createRadialGradient(
    cx, CENTER_Y, 6,
    cx, CENTER_Y, INNER_RADIUS
  );

  g.addColorStop(0, "rgba(255,255,255,0.12)");
  g.addColorStop(1, "rgba(0,0,0,0.45)");

  ctx.beginPath();
  ctx.arc(cx, CENTER_Y, INNER_RADIUS, 0, Math.PI * 2);
  ctx.fillStyle = g;
  ctx.fill();
}

function drawRing(cx, color, glowStrength) {
  glowPhase += 0.035;

  const breathing =
    glowStrength === "strong"
      ? 22 + Math.sin(glowPhase) * 12
      : 16 + Math.sin(glowPhase) * 8;

  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, CENTER_Y, REACTOR_RADIUS, 0, Math.PI * 2);
  ctx.strokeStyle = color;
  ctx.lineWidth = 7;
  ctx.shadowColor = color;
  ctx.shadowBlur = breathing;
  ctx.stroke();
  ctx.restore();
}

function drawTicks(cx) {
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.15)";
  ctx.lineWidth = 1;

  [0.25, 0.5, 0.75].forEach(p => {
    const y = CENTER_Y + INNER_RADIUS - INNER_RADIUS * 2 * p;
    ctx.beginPath();
    ctx.moveTo(cx - 10, y);
    ctx.lineTo(cx + 10, y);
    ctx.stroke();
  });

  ctx.restore();
}

function drawFuel(cx, progress, color, state) {
  if (progress <= 0) return;

  const h = INNER_RADIUS * 2 * progress;
  const baseY = CENTER_Y + INNER_RADIUS;
  const surfaceY = baseY - h;

  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, CENTER_Y, INNER_RADIUS, 0, Math.PI * 2);
  ctx.clip();

  wavePhaseA += 0.06;
  wavePhaseB += 0.035;

  ctx.beginPath();
  ctx.moveTo(cx - INNER_RADIUS, surfaceY);

  for (let x = -INNER_RADIUS; x <= INNER_RADIUS; x++) {
    const w1 = Math.sin((x * 0.08) + wavePhaseA) * 2.2;
    const w2 = Math.sin((x * 0.15) + wavePhaseB) * 1.4;
    ctx.lineTo(cx + x, surfaceY + w1 + w2);
  }

  ctx.lineTo(cx + INNER_RADIUS, baseY);
  ctx.lineTo(cx - INNER_RADIUS, baseY);
  ctx.closePath();

  const grad = ctx.createLinearGradient(0, surfaceY, 0, baseY);
  grad.addColorStop(0, "rgba(200,255,235,0.95)");
  grad.addColorStop(1, color);

  ctx.fillStyle = grad;
  ctx.shadowColor = color;
  ctx.shadowBlur = 16;
  ctx.fill();

  ctx.restore();

  /* burst bubbles ABOVE surface only */
  const now = performance.now();
  if (state === "HEALTHY" && now - lastBurst > 6000 + Math.random() * 4000) {
    lastBurst = now;
    spawnBurst(cx, surfaceY - 2, color);
  }
}

function drawBurstBubbles() {
  for (let i = burstBubbles.length - 1; i >= 0; i--) {
    const b = burstBubbles[i];
    ctx.save();
    ctx.globalAlpha = b.life * 0.4;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
    ctx.fillStyle = b.color;
    ctx.shadowColor = b.color;
    ctx.shadowBlur = 6;
    ctx.fill();
    ctx.restore();

    b.y -= b.speed;
    b.life -= 0.02;

    if (b.life <= 0) burstBubbles.splice(i, 1);
  }
}

/* ======================================================
   MAIN LOOP
====================================================== */

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (data) {
    [["weekly", WEEKLY_X], ["monthly", MONTHLY_X]].forEach(([key, cx]) => {
      const d = data[key];
      const state = getState(d);
      const baseColor = getBaseColor(key);

      drawInnerCore(cx);
      drawRing(
        cx,
        state === "WARNING"
          ? "rgba(210,140,90,1)"
          : state === "IDLE" || state === "BREAKEVEN"
            ? "rgba(180,180,180,0.9)"
            : baseColor,
        state === "HEALTHY" ? "strong" : "soft"
      );

      drawTicks(cx);
      drawFuel(cx, clamp(d.progress || 0), baseColor, state);
    });
  }

  drawBurstBubbles();

  requestAnimationFrame(render);
}

render();
</script>
</body>
</html>
