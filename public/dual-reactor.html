<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Dual Reactor â€“ Heat Stable</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  background: transparent;
  overflow: hidden;
}
canvas {
  display: block;
}
</style>
</head>

<body>
<canvas id="c" width="520" height="260"></canvas>

<script>
/* ================= CONFIG ================= */

const ENGINE_URL =
  "https://trading-dashboard-api-five.vercel.app/api/engine-ui?t=";

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

const REACTOR_RADIUS = 58;
const INNER_RADIUS = 44;
const WEEKLY_X = 170;
const MONTHLY_X = 350;
const CENTER_Y = 130;

/* ================= STATE ================= */

let data = null;

let ringPhase = 0;
let corePhase = 0;
let wavePhaseA = 0;
let wavePhaseB = 0;
let heatPhase = 0;

/* burst bubbles */
const burstBubbles = [];
let lastBurst = 0;

/* ================= FETCH ================= */

async function fetchData() {
  try {
    const res = await fetch(ENGINE_URL + Date.now(), { cache: "no-store" });
    data = await res.json();
  } catch {}
}
fetchData();
setInterval(fetchData, 10000);

/* ================= HELPERS ================= */

const clamp = v => Math.max(0, Math.min(1, v));

function getState(d) {
  if (!d.hasTrades) return "IDLE";
  if (d.pl < 0) return "WARNING";
  if (d.pl === 0) return "BREAKEVEN";
  return "HEALTHY";
}

function baseColor(type) {
  return type === "weekly"
    ? "rgba(120,255,200,0.95)"
    : "rgba(90,200,150,0.95)";
}

function spawnBurst(cx, y, color) {
  burstBubbles.push({
    x: cx,
    y,
    r: 2.5,
    life: 1,
    speed: 0.35,
    color
  });
}

/* ================= DRAW ================= */

function drawCore(cx, color) {
  corePhase += 0.012;

  const glow = 10 + Math.sin(corePhase) * 4;

  const g = ctx.createRadialGradient(
    cx, CENTER_Y, 6,
    cx, CENTER_Y, INNER_RADIUS
  );
  g.addColorStop(0, "rgba(255,255,255,0.08)");
  g.addColorStop(1, "rgba(0,0,0,0.42)");

  ctx.beginPath();
  ctx.arc(cx, CENTER_Y, INNER_RADIUS, 0, Math.PI * 2);
  ctx.fillStyle = g;
  ctx.shadowColor = color;
  ctx.shadowBlur = glow;
  ctx.fill();
}

function drawHeatDistortion(cx) {
  heatPhase += 0.004; // VERY slow

  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, CENTER_Y, INNER_RADIUS - 2, 0, Math.PI * 2);
  ctx.clip();

  for (let i = 0; i < 3; i++) {
    const r = INNER_RADIUS * (0.35 + i * 0.2);
    const wobble = Math.sin(heatPhase + i * 2) * 1.2;

    ctx.beginPath();
    ctx.arc(cx + wobble, CENTER_Y, r, 0, Math.PI * 2);
    ctx.strokeStyle = "rgba(255,255,255,0.025)";
    ctx.lineWidth = 1;
    ctx.stroke();
  }
  ctx.restore();
}

function drawRing(cx, color, active) {
  ringPhase += 0.02;

  const breathe = active
    ? 18 + Math.sin(ringPhase) * 6
    : 14 + Math.sin(ringPhase) * 4;

  ctx.beginPath();
  ctx.arc(cx, CENTER_Y, REACTOR_RADIUS, 0, Math.PI * 2);
  ctx.strokeStyle = color;
  ctx.lineWidth = 7;
  ctx.shadowColor = color;
  ctx.shadowBlur = breathe;
  ctx.stroke();
}

function drawTicks(cx) {
  ctx.strokeStyle = "rgba(255,255,255,0.14)";
  ctx.lineWidth = 1;

  [0.25, 0.5, 0.75].forEach(p => {
    const y = CENTER_Y + INNER_RADIUS - INNER_RADIUS * 2 * p;
    ctx.beginPath();
    ctx.moveTo(cx - 10, y);
    ctx.lineTo(cx + 10, y);
    ctx.stroke();
  });
}

function drawFuel(cx, progress, color, state) {
  if (state !== "HEALTHY" || progress <= 0) return;

  wavePhaseA += 0.02;
  wavePhaseB += 0.015;

  const h = INNER_RADIUS * 2 * progress;
  const baseY = CENTER_Y + INNER_RADIUS;
  const surfaceY = baseY - h;

  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, CENTER_Y, INNER_RADIUS, 0, Math.PI * 2);
  ctx.clip();

  drawTicks(cx);

  ctx.beginPath();
  for (let x = -INNER_RADIUS; x <= INNER_RADIUS; x++) {
    const w1 = Math.sin(x * 0.08 + wavePhaseA) * 2.2;
    const w2 = Math.sin(x * 0.14 + wavePhaseB) * 1.4;
    ctx.lineTo(cx + x, surfaceY + w1 + w2);
  }
  ctx.lineTo(cx + INNER_RADIUS, baseY);
  ctx.lineTo(cx - INNER_RADIUS, baseY);
  ctx.closePath();

  const grad = ctx.createLinearGradient(0, surfaceY, 0, baseY);
  grad.addColorStop(0, "rgba(200,255,235,0.95)");
  grad.addColorStop(1, color);

  ctx.fillStyle = grad;
  ctx.shadowColor = color;
  ctx.shadowBlur = 12;
  ctx.fill();

  ctx.restore();

  /* burst bubbles ABOVE surface only */
  const now = performance.now();
  if (now - lastBurst > 7000 + Math.random() * 4000) {
    lastBurst = now;
    spawnBurst(cx, surfaceY - 2, color);
  }
}

function drawBursts() {
  for (let i = burstBubbles.length - 1; i >= 0; i--) {
    const b = burstBubbles[i];

    ctx.globalAlpha = b.life * 0.4;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
    ctx.fillStyle = b.color;
    ctx.shadowColor = b.color;
    ctx.shadowBlur = 5;
    ctx.fill();

    b.y -= b.speed;
    b.life -= 0.02;

    if (b.life <= 0) burstBubbles.splice(i, 1);
  }
  ctx.globalAlpha = 1;
}

/* ================= LOOP ================= */

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (data) {
    [["weekly", WEEKLY_X], ["monthly", MONTHLY_X]].forEach(([key, cx]) => {
      const d = data[key];
      const state = getState(d);
      const base = baseColor(key);

      drawCore(cx, base);
      drawHeatDistortion(cx);

      const ringColor =
        state === "WARNING"
          ? "rgba(210,140,90,1)"
          : state === "IDLE" || state === "BREAKEVEN"
            ? "rgba(180,180,180,0.9)"
            : base;

      drawRing(cx, ringColor, state === "HEALTHY");
      drawFuel(cx, clamp(d.progress || 0), base, state);
    });
  }

  drawBursts();
  requestAnimationFrame(render);
}

render();
</script>
</body>
</html>
