<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>System Status Core</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  background: transparent !important;
  overflow: hidden;
}

.container {
  width: 260px;
  height: 190px;
  display: flex;
  align-items: center;
  justify-content: center;
}

canvas {
  background: transparent;
  display: block;
}
</style>
</head>

<body>

<div class="container">
  <canvas id="status" width="260" height="220"></canvas>
</div>

<script>
const canvas = document.getElementById("status");
const ctx = canvas.getContext("2d", { alpha: true });

const CENTER = { x: canvas.width / 2, y: canvas.height / 2 };
const RADIUS = 66;
const INNER_RADIUS = 52;

let waveOffset = 0;
let glowPhase = 0;
let shimmerPhase = 0;
let heatPhase = 0;
let boilPhase = 0;
let latestData = null;

/* ================= BUBBLES (MINIMAL) ================= */
const bubbles = [];
let lastBurst = 0;

function createBubble({ burst = false } = {}) {
  return {
    x: (Math.random() * 2 - 1) * INNER_RADIUS * 0.55,
    y: Math.random() * INNER_RADIUS * 0.2,
    r: burst ? 1.1 + Math.random() * 0.4 : 1.2 + Math.random() * 0.5,
    speed: burst ? 0.28 + Math.random() * 0.12 : 0.1 + Math.random() * 0.08,
    drift: (Math.random() * 2 - 1) * 0.04,
    alpha: burst ? 0.22 : 0.12,
    burst,
    life: 1
  };
}

// only 3 base bubbles
for (let i = 0; i < 3; i++) bubbles.push(createBubble());

/* ================= FETCH ================= */
async function fetchData() {
  try {
    const res = await fetch(
      "https://trading-dashboard-api-five.vercel.app/api/engine?t=" + Date.now(),
      { cache: "no-store" }
    );
    latestData = await res.json();
  } catch {}
}
fetchData();
setInterval(fetchData, 10000);

/* ================= STATUS ================= */
function getStatus(d) {
  if (!d) return "INACTIVE";
  if (d.weekly?.trades >= 1) return "ACTIVE";
  if (d.monthly?.trades >= 1) return "IDLE";
  return "INACTIVE";
}

/* ================= COLORS ================= */
function getColors(status) {
  if (status === "ACTIVE") {
    return {
      ring: "rgba(120,255,200,1)",
      glow: "rgba(120,255,200,1)",
      fuel: "rgba(120,255,200,0.7)",
      bubble: "rgba(160,220,205,1)" // coolant-tinted, not white
    };
  }
  if (status === "IDLE") {
    return {
      ring: "rgba(255,190,110,0.9)",
      glow: "rgba(255,190,110,0.6)",
      fuel: null
    };
  }
  return {
    ring: "rgba(170,170,170,0.9)",
    glow: "rgba(170,170,170,0.5)",
    fuel: null
  };
}

/* ================= INNER DEPTH ================= */
function drawInnerDepth() {
  const g = ctx.createRadialGradient(
    CENTER.x, CENTER.y, INNER_RADIUS * 0.3,
    CENTER.x, CENTER.y, INNER_RADIUS
  );
  g.addColorStop(0, "rgba(255,255,255,0.06)");
  g.addColorStop(1, "rgba(0,0,0,0.35)");

  ctx.beginPath();
  ctx.arc(CENTER.x, CENTER.y, INNER_RADIUS, 0, Math.PI * 2);
  ctx.fillStyle = g;
  ctx.fill();
}

/* ================= RING ================= */
function drawRing(color, glow, status) {
  glowPhase += 0.10;
  const breathing = 30 + Math.sin(glowPhase) * 12;

  ctx.save();
  ctx.beginPath();
  ctx.arc(CENTER.x, CENTER.y, RADIUS, 0, Math.PI * 2);
  ctx.strokeStyle = color;
  ctx.lineWidth = 15;
  ctx.shadowColor = glow;
  ctx.shadowBlur = breathing;
  ctx.stroke();
  ctx.restore();

  if (status === "ACTIVE") {
    shimmerPhase += 0.008;
    ctx.beginPath();
    ctx.arc(
      CENTER.x,
      CENTER.y,
      RADIUS,
      shimmerPhase,
      shimmerPhase + Math.PI / 6
    );
    ctx.strokeStyle = "rgba(255,255,255,0.1)";
    ctx.lineWidth = 1.2;
    ctx.stroke();
  }
}

/* ================= FUEL + CLEAN BUBBLES ================= */
function drawFuel(level, color, bubbleColor, status) {
  if (!color || level <= 0) return;

  const h = INNER_RADIUS * 2 * level;
  const baseY = CENTER.y + INNER_RADIUS;
  const surfaceY = baseY - h;

  boilPhase += 0.01;

  ctx.save();
  ctx.beginPath();
  ctx.arc(CENTER.x, CENTER.y, INNER_RADIUS, 0, Math.PI * 2);
  ctx.clip();

  /* surface */
  ctx.beginPath();
  ctx.moveTo(CENTER.x - INNER_RADIUS, surfaceY);

  for (let x = -INNER_RADIUS; x <= INNER_RADIUS; x++) {
    const wave = Math.sin((x + waveOffset) * 0.045) * 3;
    const heat = Math.sin((x * 0.12) + heatPhase) * 2;
    const convection = Math.sin(boilPhase + x * 0.03) * 1.5;
    ctx.lineTo(CENTER.x + x, surfaceY + wave + heat + convection);
  }

  ctx.lineTo(CENTER.x + INNER_RADIUS, baseY);
  ctx.lineTo(CENTER.x - INNER_RADIUS, baseY);
  ctx.closePath();

  const grad = ctx.createLinearGradient(0, surfaceY, 0, baseY);
  grad.addColorStop(0, "rgba(200,255,235,0.95)");
  grad.addColorStop(1, color);

  ctx.fillStyle = grad;
  ctx.shadowColor = color;
  ctx.shadowBlur = 14;
  ctx.fill();

  if (status === "ACTIVE") {
    const now = performance.now();

    // very soft burst (mostly above surface)
    if (now - lastBurst > 9000 + Math.random() * 5000) {
      lastBurst = now;
      bubbles.push(createBubble({ burst: true }), createBubble({ burst: true }));
    }

    for (const b of bubbles) {
      const yPos = baseY - b.y;

      // hide most bubbles inside coolant
      if (!b.burst && yPos < surfaceY + 12) continue;

      ctx.globalAlpha = b.alpha * b.life;
      ctx.beginPath();
      ctx.arc(CENTER.x + b.x, yPos, b.r, 0, Math.PI * 2);
      ctx.fillStyle = bubbleColor;
      ctx.fill();

      b.y += b.speed;
      b.x += b.drift;

      // fade quickly above surface
      if (b.burst && yPos < surfaceY - 6) b.life -= 0.15;

      if (b.life <= 0 || b.y > h + 16) {
        Object.assign(b, createBubble());
      }
    }
    ctx.globalAlpha = 1;
  }

  ctx.restore();
}

/* ================= LOOP ================= */
function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const base = getColors("INACTIVE");
  drawInnerDepth();
  drawRing(base.ring, base.glow, "INACTIVE");

  if (latestData) {
    const status = getStatus(latestData);
    const colors = getColors(status);

    drawRing(colors.ring, colors.glow, status);

    if (status === "ACTIVE") {
      const winrate = Math.max(
        0,
        Math.min(1, (latestData.weekly?.winrate || 0) / 100)
      );
      drawFuel(winrate, colors.fuel, colors.bubble, status);
    }
  }

  waveOffset += 0.35;
  heatPhase += 0.04;

  requestAnimationFrame(render);
}

render();
</script>

</body>
</html>
