<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>System Status Core</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  background: transparent;
  overflow: hidden;
}

.container {
  width: 260px;
  height: 190px;
  display: flex;
  align-items: center;
  justify-content: center;
}

canvas {
  background: transparent;
}
</style>
</head>

<body>

<div class="container">
  <canvas id="status" width="220" height="180"></canvas>
</div>

<script>
const canvas = document.getElementById("status");
const ctx = canvas.getContext("2d");

const CENTER = { x: 110, y: 90 };
const RADIUS = 66;
const INNER_RADIUS = 52;

let waveOffset = 0;

/* ===== STATE (never undefined) ===== */
let systemState = {
  status: "INACTIVE",
  winrate: 0
};

/* ===== SAFE FETCH (timer based) ===== */
async function updateState() {
  try {
    const res = await fetch(
      "https://trading-dashboard-api-five.vercel.app/api/engine?t=" + Date.now(),
      { cache: "no-store" }
    );
    const data = await res.json();

    if (data.weekly?.trades > 0) {
      systemState.status = "ACTIVE";
      systemState.winrate = data.weekly.winrate || 0;
    } else if (data.monthly?.trades > 0) {
      systemState.status = "IDLE";
      systemState.winrate = 0;
    } else {
      systemState.status = "INACTIVE";
      systemState.winrate = 0;
    }
  } catch {
    // keep last known state
  }
}

/* fetch every 10 seconds */
updateState();
setInterval(updateState, 10000);

/* ===== COLORS ===== */
function getColors(status) {
  if (status === "ACTIVE") {
    return {
      ring: "rgba(110,255,200,1)",
      fuel: "rgba(110,255,200,0.75)",
      mist: "rgba(110,255,200,0.15)"
    };
  }
  if (status === "IDLE") {
    return {
      ring: "rgba(255,185,120,0.85)",
      fuel: null,
      mist: "rgba(255,185,120,0.12)"
    };
  }
  return {
    ring: "rgba(180,180,180,0.6)",
    fuel: null,
    mist: null
  };
}

/* ===== DRAW ===== */
function drawRing(color) {
  ctx.beginPath();
  ctx.arc(CENTER.x, CENTER.y, RADIUS, 0, Math.PI * 2);
  ctx.strokeStyle = color;
  ctx.lineWidth = 8;
  ctx.shadowColor = color;
  ctx.shadowBlur = 36;
  ctx.stroke();
  ctx.shadowBlur = 0;
}

function drawInner(color) {
  if (!color) return;
  ctx.beginPath();
  ctx.arc(CENTER.x, CENTER.y, INNER_RADIUS, 0, Math.PI * 2);
  ctx.fillStyle = color;
  ctx.fill();
}

function drawFuel(level, color) {
  if (!color || level <= 0) return;

  const h = INNER_RADIUS * 2 * level;
  const baseY = CENTER.y + INNER_RADIUS;

  ctx.save();
  ctx.beginPath();
  ctx.arc(CENTER.x, CENTER.y, INNER_RADIUS, 0, Math.PI * 2);
  ctx.clip();

  ctx.beginPath();
  ctx.moveTo(CENTER.x - INNER_RADIUS, baseY - h);
  for (let x = -INNER_RADIUS; x <= INNER_RADIUS; x++) {
    const y =
      Math.sin((x + waveOffset) * 0.05) * 4 +
      (baseY - h);
    ctx.lineTo(CENTER.x + x, y);
  }
  ctx.lineTo(CENTER.x + INNER_RADIUS, baseY);
  ctx.lineTo(CENTER.x - INNER_RADIUS, baseY);
  ctx.closePath();

  ctx.fillStyle = color;
  ctx.fill();
  ctx.restore();
}

/* ===== MAIN LOOP (never async) ===== */
function loop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const colors = getColors(systemState.status);

  drawInner(colors.mist);
  drawRing(colors.ring);

  if (systemState.status === "ACTIVE") {
    drawFuel(systemState.winrate / 100, colors.fuel);
  }

  waveOffset += 0.6;
  requestAnimationFrame(loop);
}

loop();
</script>

</body>
</html>
